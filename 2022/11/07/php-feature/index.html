<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zhangMini"><title>PHP 特性 · Mini's blog</title><meta name="description" content="intval($var, $base) intval() 函数用于获取变量的整数值。其中，$base 参数用于指定进制， base=0 表示根据 $var 开始的数字判断进制：0x 或 0X 开头的为 16 进制，0 开头的为 8 进制，其他为 10 进制

intval() 函数转换数组时，不关心"><meta name="keywords" content="Security, life"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mini's blog</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">tags</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>PHP 特性</a></h3></div><div class="post-content"><h3 id="intval-var-base"><a href="#intval-var-base" class="headerlink" title="intval($var, $base) "></a><code>intval($var, $base) </code></h3><p><code>intval()</code> 函数用于获取变量的整数值。其中，<code>$base</code> 参数用于指定进制， <code>base=0</code> 表示根据 <code>$var</code> 开始的数字判断进制：<code>0x</code> 或 <code>0X</code> 开头的为 16 进制，<code>0</code> 开头的为 8 进制，其他为 10 进制</p>
<blockquote>
<p><code>intval()</code> 函数转换数组时，不关心数组的内容，只判断数组中有没有元素。空数组返回 0，非空数组返回 1</p>
</blockquote>
<h3 id="md5-amp-sha1"><a href="#md5-amp-sha1" class="headerlink" title="md5() &amp; sha1()"></a><code>md5()</code> &amp; <code>sha1()</code></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>]))</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组不能被 <code>md5()</code> 和 <code>sha1()</code> 加密，对数组加密返回 <code>null</code> </p>
</blockquote>
<p>所以可以构造如下 payload 绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[]=<span class="number">1</span>&amp;b[]=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="md5-string-true"><a href="#md5-string-true" class="headerlink" title="md5(string, true)"></a><code>md5(string, true)</code></h4><ul>
<li><code>md5()</code> 函数第二个参数默认为 <code>false</code>，返回 32 字符的十六进制数字，每个字符代表4位二进制数据，总共 128 位</li>
<li>当 <code>md5</code> 第二个参数为 <code>true</code> 时，返回 16 字符的原始二进制数据，每个字节由 8 位组成，总共也是 128 位，但用二进制形式紧凑地表示，而不是人类可读的十六进制文本，所以一般会有乱码</li>
</ul>
<p>所以可以利用 <code>md5(string, true)</code> 构造出我们想要的字符串，脚本如下，其中 <code>stripos</code> 中填入我们想要构造的字符串</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造 sql 闭合语句 &#x27; or &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;;) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="variable">$c</span> = <span class="number">0</span>; <span class="variable">$c</span> &lt; <span class="number">1000000</span>; <span class="variable">$c</span>++, <span class="variable">$i</span>++)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">stripos</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>, <span class="literal">true</span>), <span class="string">&#x27;\&#x27;or\&#x27;&#x27;</span>) !== <span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;\nmd5(<span class="subst">$i</span>) = &quot;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$i</span>, <span class="literal">true</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到 ffifdyop，它的 md5 为 `’or’6XXXX`，其中 `XXXX` 为乱码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="md5-弱比较"><a href="#md5-弱比较" class="headerlink" title="md5() 弱比较"></a><code>md5()</code> 弱比较</h4><p>在进行 <code>==</code> 弱比较时，会先将两边的变量类型转化成相同的，再进行比较</p>
<p>0e 在比较的时候会将其视作为科学计数法，所以无论 0e 后面是什么，0 的多少次方还是 0</p>
<p>于是可以去寻找明文不同但 MD5 值为 “0exxxxx”，比如 QNKCDZO 和 s878926199a</p>
<h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><h4 id="动态变量覆盖"><a href="#动态变量覆盖" class="headerlink" title="$$ 动态变量覆盖"></a><code>$$</code> 动态变量覆盖</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$a</span> = <span class="variable">$$b</span></span><br></pre></td></tr></table></figure>

<p>该语句的效果类似于将 <code>$a</code> 的地址指向 <code>$b</code> ，所以无论 <code>$b</code> 怎么改变值，<code>$a</code> 的值也会跟着改变</p>
<h4 id="extract-函数变量覆盖"><a href="#extract-函数变量覆盖" class="headerlink" title="extract() 函数变量覆盖"></a><code>extract()</code> 函数变量覆盖</h4><p><code>extract()</code> 函数从数组中将变量导入到当前的变量表。该函数使用数组键名作为变量名，使用数组键值作为变量值</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&#x27;nickname&#x27;</span> =&gt; <span class="string">&#x27;1ndex&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$nickname</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//运行结果为输出 1ndex</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数中第二个参数 <code>flags</code> 默认值为 <code>EXTR_OVERWRITE</code>，表示如果有重复的变量名，将会覆盖原有变量</p>
</blockquote>
<h4 id="parse-str-函数变量覆盖"><a href="#parse-str-函数变量覆盖" class="headerlink" title="parse_str 函数变量覆盖"></a><code>parse_str</code> 函数变量覆盖</h4><p><code>parse_str()</code> 函数把字符串解析成多个变量。其作用就是解析字符串并注册成变量</p>
<blockquote>
<p>其在注册变量之前不会验证当前变量是否存在，所以直接覆盖掉已有变量</p>
</blockquote>
<h4 id="register-globals-on-变量覆盖"><a href="#register-globals-on-变量覆盖" class="headerlink" title="register_globals = on 变量覆盖"></a><code>register_globals = on</code> 变量覆盖</h4><p>全局变量注册，该配置在 PHP5.3 之前，默认开启；PHP5.3 默认关闭，PHP5.6 及 5.7 已经被移除</p>
<blockquote>
<p>全局变量设置开启时，传递过来的值(POST&#x2F;GET&#x2F;Cookie)会被直接注册为全局变量而使用，这会造成全局变量覆盖</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/blfg.php?authorized=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 $authorized 为全局变量，值为 1</span></span><br></pre></td></tr></table></figure>

<h4 id="import-request-variables-变量覆盖"><a href="#import-request-variables-变量覆盖" class="headerlink" title="import_request_variables() 变量覆盖"></a><code>import_request_variables()</code> 变量覆盖</h4><p>该函数将 GET&#x2F;POST&#x2F;COOKIE 变量导入到全局作用域中，当禁止 <code>register_golbals</code> 却又想用一些全局变量，可以尝试使用该函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">import_request_variables</span>(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># string 指定导入哪些变量为全局变量，G 为 GET 变量、P 为 POST 变量、C 为 Cookie 变量</span></span><br></pre></td></tr></table></figure>

<h3 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a><code>ereg()</code></h3><p><code>ereg()</code> 函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回 true,否则,则返回 false</p>
<blockquote>
<p>该函数存在 NULL <code>%00</code> 截断漏洞，读取到 <code>%00</code> 就不继续读取了</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="=="></a><code>==</code></h3><p>比较运算符 <code>==</code> 会进行类型转换（称为弱类型比较）</p>
<blockquote>
<p>PHP 在进行弱类型比较时，会将字符串转换成整数（如果可能），然后再进行比较<br>PHP 会从字符串的开头开始读取，直到遇到第一个非数字字符为止。如 <code>&#39;123abc&#39;</code> 会被转换成 <code>123</code>，<code>&#39;abc123&#39;</code> 会被转换成 <code>0</code></p>
</blockquote>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a><code>trim()</code></h3><p><code>trim()</code> 函数用于删除字符串两端的空白字符或其他预定义字符</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">trim</span>(<span class="variable">$num</span>)!==<span class="string">&#x27;36&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>去除普通空格、制表符(%09)、换行符(%0a)、回车符(%0d)、空字节符(%00)、垂直制表符（%0b），<strong>但不去除换页符（%0c）</strong></p>
</blockquote>
<h3 id="PHP-GET-x2F-POST-变量名特性"><a href="#PHP-GET-x2F-POST-变量名特性" class="headerlink" title="PHP GET&#x2F;POST 变量名特性"></a>PHP GET&#x2F;POST 变量名特性</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;CTF_SHOW.COM&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>如上例所示，通常来说，由于 PHP 中变量名只有数字字母下划线，被 GET&#x2F;POST 传递的变量名中如果含有 <code>.</code> <code> </code> <code>+</code>  <code>[</code> 会被转换成 <code>_</code></p>
<blockquote>
<p>但 PHP 有个特性就是如果传入 <code>[</code>，他被转换为 <code>_</code> 之后，后面的字符会被保留下来不会被替换，所以可以构造如下 payload 生成 <code>CTF_SHOW.COM</code> 变量 </p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTF[SHOW.COM = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars"></a><code>get_defined_vars</code></h3><p>该函数会返回由所有已定义变量所组成的数组</p>
<blockquote>
<p>可以尝试利用该函数获取 <code>$flag</code> 变量</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="_() 函数"></a><code>_()</code> 函数</h3><p><code>_()</code> 是一个函数，它是 <code>gettext()</code> 函数的简写形式，其具体作用参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lost-1987/articles/3309693.html">关于PHP中gettext的用法</a></p>
<blockquote>
<p>当需要构造一个函数时，但函数名的过滤条件字母数字，如下，则可以尝试使用 <code>_()</code> 函数绕过</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]/i&#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PHP-PCRE-正则表达式匹配次数特性"><a href="#PHP-PCRE-正则表达式匹配次数特性" class="headerlink" title="PHP PCRE 正则表达式匹配次数特性"></a>PHP PCRE 正则表达式匹配次数特性</h3><p>PHP 为了防止正则表达式的拒绝服务攻击，给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit<br>回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，<code>preg_match</code> 将不再返回非 <code>1</code> 和 <code>0</code>，而是 <code>false</code></p>
<p>因此，当遇到下面的匹配机制时</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;f&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$f</span> = (String)<span class="variable">$_POST</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/.+?ctfshow/is&#x27;</span>, <span class="variable">$f</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;bye!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$f</span>,<span class="string">&#x27;36Dctfshow&#x27;</span>) === <span class="literal">FALSE</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;bye!!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以构建一个很大的数据绕过匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot; &quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;dotast&#x27;</span>*<span class="number">170000</span>+<span class="string">&#x27;ctfshow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url=url,data=data)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure>

<h3 id="PHP-内置类（原生类）-amp-匿名类"><a href="#PHP-内置类（原生类）-amp-匿名类" class="headerlink" title="PHP 内置类（原生类）&amp; 匿名类"></a>PHP 内置类（原生类）&amp; 匿名类</h3><p>PHP 的类分为 内置类、用户自定义类、匿名类</p>
<h4 id="内置类"><a href="#内置类" class="headerlink" title="内置类"></a>内置类</h4><p>PHP 原生类(Built-in Classes)是在标准 PHP 库中已经封装好的类，它们是由 PHP 本身提供的，不需要用户手动定义。在其中，有些类具有一些功能(例如文件读取、目录遍历等)，这就有了利用机会，我们只需要实例化这些类，就可以实现文件读取等敏感操作</p>
<p>常用的内置类有如下几个</p>
<ol>
<li><p><code>Error</code> : Error 是所有PHP内部错误类的基类，用于自动自定义一个 <code>Error</code>。该类中有一个 <code>_toString</code> 方法，如果把它当做字符串使用，就会触发该魔术方法。例如我们对其进行输出操作 <code>echo new Error()</code>，此时就会自动调用 <code>__toString</code> 魔术方法。(适用于 PHP7 及以上版本)</p>
</li>
<li><p><code>Exception</code> : Exception 是所有用户级异常的基类，它与 <code>Error</code> 类似，也存在一个 <code>_toString</code> 方法。(适用于 PHP5 及以上版本)</p>
</li>
<li><p><code>SplFileObject</code> : 该类的构造方法可以构造一个新的文件对象用于后续的读取。其大致原理为当类中 <code>__toString</code> 魔术方法被触发时，如果类中内容为存在文件名，那么它会对此文件名进行内容获取</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$context</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码会输出 `/etc/passwd` 文件的内容，但只能读取一行，想读取多行的话可以 `foreach` 遍历输出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FilesystemIterator</code> : 该类可以理解为一个文件系统迭代器，其构造方法将会创建一个指定目录的迭代器。该类可以用于遍历指定目录中的文件名，其大致原理为当类中 <code>__toString</code> 魔术方法被 <code>echo</code> 等方法触发时，会返回这个迭代器的第一项，亦即返回文件名</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">FilesystemIterator</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$f</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DirectoryIterator</code> : 该类可以理解为一个目录迭代器，其构造方法将会创建一个指定目录的迭代器，可以获取其指定目录下全部文件名。其利用方法类似于 <code>FilesystemIterator</code></p>
</li>
<li><p><code>GlobIterator</code> : 类似于 <code>DirectoryIterator</code> 和 <code>FilesystemIterator</code>，但是可以通过模式匹配来寻找文件路径</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;/*flag*&quot;</span>); </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配当前目录下所有包含 flag 的文件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>PHP7 的新特性，匿名类是一种没有类名的类，可以用来实例化对象，通过 <code>new class</code> 关键字来实例化匿名类</p>
<h3 id="无字母数字绕过正则表达式"><a href="#无字母数字绕过正则表达式" class="headerlink" title="无字母数字绕过正则表达式"></a>无字母数字绕过正则表达式</h3><p>如果题目过滤字母数字，如下所示</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/i&#x27;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以通过脚本通过异或构造出 payload 绕过</p>
<p>如 <code>system(&#39;ls&#39;)</code> 可以构造为 <code>(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;)</code></p>
<p>具体见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/miuzzx/article/details/109143413">无字母数字绕过正则表达式总结</a></p>
<h3 id="php-mt-seed"><a href="#php-mt-seed" class="headerlink" title="php_mt_seed"></a>php_mt_seed</h3><p>php 通过 <code>mt_srand(seed)</code> 函数通过分发 seed 种子，依靠 <code>mt_rand()</code> 使用 Mersenne Twister 算法返回随机整数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="title function_ invoke__">mt_srand</span>(<span class="number">123</span>);    </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mt_rand</span>();</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>如何生成的随机整数，它与设置的 seed 值和调用该函数的次数有关</p>
<p>使用 php_mt_seed 即可通过随机数进行种子的爆破</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time ./php_mt_seed 984489752</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 PHP 4.2.0 开始，随机数生成器自动播种，因此可以不使用 <code>mt_srand</code> 函数。当不使用随机数播种函数时，php 也会自动为随机数播种，因此是否确定种子都不会影响正常运行</p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/web/" title="web">web </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/11/07/php-feature/,Mini's blog,PHP 特性,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/11/08/Assembly-language/" title="汇编基础及IDA快捷键">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/11/04/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80/" title="内网基础">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>